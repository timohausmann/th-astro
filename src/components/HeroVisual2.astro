---
// No props needed for this visual
---

<!-- SVG container for SVG.js to mount into -->
<div id="synergy-svg-container"></div>

<style>
    #synergy-svg-container {
        position: absolute;
        display: flex;
        align-items: stretch;
        justify-content: center;
        inset: 0;
        pointer-events: none;
    }
    #synergy-svg-container :global(svg) {
        width: 100%;
        height: 100%;
        display: block;
        object-fit: cover;
    }
</style>

<script>
    // @ts-ignore
    import { SVG } from "@svgdotjs/svg.js";
    // @ts-ignore
    import type { Circle } from "@svgdotjs/svg.js";

    interface Ring {
        element: Circle;
        scale: number;
    }

    interface SpawnPoint {
        x: number;
        y: number;
        rings: Ring[];
        angle: number;
        radius: number;
    }

    window.addEventListener("DOMContentLoaded", () => {
        const size = 720;
        const centerX = size / 2;
        const centerY = size / 2;

        // Define spawn points with initial positions and rotation properties
        const spawnCount = 2;
        const spawns: SpawnPoint[] = Array(spawnCount)
            .fill(0)
            .map((val, i) => ({
                x: 0,
                y: 0,
                rings: [],
                angle: - Math.PI/2 + ((Math.PI * 2 * i) / spawnCount),
                radius: size * 0.4,
            }));

        // Configuration
        const maxRings = 32; // Number of rings per spawn point
        const ringGrowthRate = 10; // Pixels per second growth rate
        const maxRingSize = size * 0.95; // Increased to almost full size
        // const ringStrokeWidth = 1;//size * 0.005;

        const draw = SVG()
            .addTo("#synergy-svg-container")
            .size(size, size)
            .viewbox(0, 0, size, size);

        // Initialize rings for each spawn point
        spawns.forEach((spawn) => {
            for (let i = 0; i < maxRings; i++) {
                spawn.angle += Math.PI / maxRings;
                spawn.x = centerX + Math.cos(spawn.angle) * spawn.radius;
                spawn.y = centerY + Math.sin(spawn.angle) * spawn.radius;
                const ring = draw
                    .circle(0)
                    .center(spawn.x, spawn.y)
                    .fill("none")
                    .stroke({
                        color: "rgba(255 255 255 / 0.1)",
                        width: 2,
                        opacity: 1,
                    });
                spawn.rings.push({
                    element: ring,
                    scale: (i / maxRings) * maxRingSize,
                });
            }
        });

        let lastTime = performance.now();
        function animateRings(currentTime: number) {
            const deltaTime = (currentTime - lastTime) / 1000; // Convert to seconds
            lastTime = currentTime;

            spawns.forEach((spawn) => {
                spawn.rings.forEach((ring, i) => {
                    // Update scale based on delta time
                    ring.scale += ringGrowthRate * deltaTime;

                    // Update ring properties
                    ring.element
                        .radius(Math.max(0, ring.scale))
                        .stroke({
                            opacity: Math.sin(
                                (ring.scale / maxRingSize) * Math.PI
                            ),
                        });

                    // Reset ring if it reaches max size
                    if (ring.scale >= maxRingSize) {
                        ring.scale = 0;
                        spawn.angle += Math.PI / maxRings;
                        spawn.x =
                            centerX + Math.cos(spawn.angle) * spawn.radius;
                        spawn.y =
                            centerY + Math.sin(spawn.angle) * spawn.radius;
                        ring.element.center(spawn.x, spawn.y);
                    }

                    // Ensure scale never goes negative
                    ring.scale = Math.max(1, ring.scale);
                });
            });

            requestAnimationFrame(animateRings);
        }

        requestAnimationFrame(animateRings);
    });
</script>